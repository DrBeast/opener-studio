import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.42.2';

// Define CORS headers using a constant
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'Authorization, Content-Type, x-client-info, apikey',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

// Define the Gemini API endpoint
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent';

// Define the expected structure for each suggested contact object generated by the AI
interface SuggestedContactOutput {
  name: string;
  role?: string;
  location?: string;
  linkedin_url?: string;
  email?: string;
  bio_summary?: string;
  how_i_can_help?: string;
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, {
      headers: corsHeaders
    });
  }

  // Create a Supabase client with the logged-in user's Auth token
  const authHeader = req.headers.get('Authorization');
  const supabaseClient = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_ANON_KEY') ?? '', // Use ANON key for client-side calls
    {
      global: {
        headers: { Authorization: authHeader ?? '' },
      },
    }
  );

  // Get the authenticated user's ID from the Supabase Auth context
  const { data: { user }, error: userError } = await supabaseClient.auth.getUser();

  if (userError || !user) {
    console.error('Authentication failed:', userError?.message);
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Authentication failed.',
      error: userError?.message
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 401,
    });
  }

  const userId = user.id;

  // Get the company_id from the request body
  const { company_id } = await req.json();

  if (!company_id) {
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Missing company_id in request body.',
      error: 'company_id is required.'
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      },
      status: 400,
    });
  }

  // Get the Gemini API Key securely from Supabase Secrets
  const geminiApiKey = Deno.env.get('GEMINI_API_KEY');

  if (!geminiApiKey) {
    console.error('Gemini API key not set in Supabase secrets.');
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Server configuration error.',
      error: 'Gemini API key not configured.'
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  // 1. Fetch existing contacts for this user to prevent duplicates
  const { data: existingContacts, error: existingContactsError } = await supabaseClient
    .from('contacts')
    .select('first_name, last_name, role, company_id')
    .eq('user_id', userId);
    
  if (existingContactsError) {
    console.error('Error fetching existing contacts:', existingContactsError.message);
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to check for existing contacts.',
      error: existingContactsError.message
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      },
      status: 500
    });
  }

  // Create a list of existing contact names for comparison
  const existingContactNames = existingContacts?.map(contact => 
    `${contact.first_name} ${contact.last_name}`.toLowerCase().trim()
  ) || [];

  // 2. Fetch the user's overall processed background summary from the user_summaries table
  const { data: userSummaryData, error: fetchSummaryError } = await supabaseClient
    .from('user_summaries')
    .select('*') // Fetch all columns from the user_summaries row
    .eq('user_id', userId)
    .single(); // Expecting one summary row per user

  if (fetchSummaryError || !userSummaryData) {
    console.error('Error fetching user summary:', fetchSummaryError?.message || 'Summary not found in user_summaries.');
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to fetch user background summary.',
      error: fetchSummaryError?.message || 'User summary data missing.'
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  const userSummary = userSummaryData;

  // 3. Fetch the user's job target criteria from the target_criteria table
  const { data: targetCriteria, error: fetchCriteriaError } = await supabaseClient
    .from('target_criteria')
    .select('*') // Fetch all columns
    .eq('user_id', userId)
    .single();

  if (fetchCriteriaError || !targetCriteria) {
    console.error('Error fetching target criteria:', fetchCriteriaError?.message || 'Criteria not found.');
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to fetch user target criteria.',
      error: fetchCriteriaError?.message || 'User target criteria missing.'
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  // 4. Fetch the details of the selected company from companies
  // RLS should ensure the user can only fetch their own companies
  const { data: companyData, error: fetchCompanyError } = await supabaseClient
    .from('companies')
    .select('*') // Fetch all columns
    .eq('company_id', company_id)
    .eq('user_id', userId) // Double check user_id for security
    .single();

  if (fetchCompanyError || !companyData) {
    console.error(`Error fetching company data for ID ${company_id}:`, fetchCompanyError?.message || 'Company not found.');
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to fetch company details.',
      error: fetchCompanyError?.message || `Company with ID ${company_id} not found for this user.`
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  // 4. Construct the prompt for the Gemini API - UPDATED to request 1 contact
  const prompt = `
  You are an AI assistant helping a professional identify key contacts within a company for job search networking.
  Below is the user's professional background summary, their job target criteria, and details about the target company.

  User Background Summary (Synthesized):
  Overall Blurb: ${userSummary.overall_blurb ?? 'N/A'}
  Experience Highlights: ${userSummary.combined_experience_highlights ? JSON.stringify(userSummary.combined_experience_highlights) : 'N/A'}
  Education Highlights: ${userSummary.combined_education_highlights ? JSON.stringify(userSummary.combined_education_highlights) : 'N/A'}
  Key Skills: ${userSummary.key_skills ? JSON.stringify(userSummary.key_skills) : 'N/A'}
  Domain Expertise: ${userSummary.domain_expertise ? JSON.stringify(userSummary.domain_expertise) : 'N/A'}
  Technical Expertise: ${userSummary.technical_expertise ? JSON.stringify(userSummary.technical_expertise) : 'N/A'}
  Value Proposition Summary: ${userSummary.value_proposition_summary ?? 'N/A'}

  User Job Target Criteria:
  Target Functions: ${targetCriteria.target_functions ? JSON.stringify(targetCriteria.target_functions) : 'Any'}
  Target Locations: ${targetCriteria.target_locations ? JSON.stringify(targetCriteria.target_locations) : 'Any'}
  Target WFH Preference: ${targetCriteria.target_wfh_preference ? JSON.stringify(targetCriteria.target_wfh_preference) : 'Any'}
  Free-form Role And Company Description: ${targetCriteria.free_form_role_description ?? 'None provided'}
  Target Industries: ${targetCriteria.target_industries ? JSON.stringify(targetCriteria.target_industries) : 'Any'}
  Target Sizes: ${targetCriteria.target_sizes ? JSON.stringify(targetCriteria.target_sizes) : 'Any'}
  Target Public/Private: ${targetCriteria.target_public_private ? JSON.stringify(targetCriteria.target_public_private) : 'Any'}
  Similar Companies (Inspiration): ${targetCriteria.similar_companies ? JSON.stringify(targetCriteria.similar_companies) : 'None provided'}
  Visa Sponsorship Required: ${targetCriteria.visa_sponsorship_required ? 'Yes' : 'No'}

  Target Company Details:
  Company Name: ${companyData.name}
  Company Description: ${companyData.ai_description ?? 'N/A'}
  Industry: ${companyData.industry ?? 'N/A'}
  Key Locations: ${companyData.hq_location ?? 'N/A'}
  Estimated Headcount: ${companyData.estimated_headcount ?? 'N/A'}
  Estimated Revenue: ${companyData.estimated_revenue ?? 'N/A'}
  WFH Policy: ${companyData.wfh_policy ?? 'N/A'}
  Public/Private: ${companyData.public_private ?? 'N/A'}

  IMPORTANT: The following contacts already exist in the user's network, so DO NOT suggest anyone with these names or very similar variations:
  ${JSON.stringify(existingContactNames)}

  Your task is to identify 1 key individual within ${companyData.name} who would be most relevant for the user to connect with for job search networking, based on the user's background and target criteria. Focus on publicly available information and ensure the suggested contact is NOT a duplicate of existing contacts.

  When identifying the contact, consider the user's current role and target functions, aiming for individuals in roles at or above the user's current level, understanding that seniority can vary significantly based on company size. Do not prioritize contacts based on their location.

  Prioritize individuals in roles like:
  - Leaders in the user's target function (1-2 levels above user's current/target seniority)
  - Relevant Executives (within 3 levels of user's target seniority)
  - Potential Peers currently holding similar roles/teams (at or above user's current level)
  - Recruiters or Talent Acquisition professionals focused on relevant functions/levels

  Provide the following information in a JSON array with exactly 1 contact object:

  For the contact object in the array:
  - "name": Full Name of the contact (ensure this is NOT similar to any existing contact names listed above).
  - "role": The contact's job title/role.
  - "location": The contact's location (if available from public data).
  - "linkedin_url": Public LinkedIn URL if found (often hard to find reliably from public data).
  - "email": Public email address if found (very unlikely from public data). Do NOT guess or generate email addresses.
  - "bio_summary": A brief, 1-2 sentence summary of the contact's background or relevance based on publicly available information.
  - "how_i_can_help": A brief, 1-2 sentence explanation of *how the user* (referring to the user's background and skills) can potentially be of help or provide value to *this specific contact* or their team/company, based on the context.

  Ensure the output is a valid JSON array with exactly 1 contact object.

  Generate the JSON array:
  `;

  // 5. Make the call to the Gemini API
  try {
    const response = await fetch(GEMINI_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': geminiApiKey,
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: prompt }]
        }],
        generationConfig: {
           temperature: 0.7,
           responseMimeType: "application/json"
        },
      }),
    });

    if (!response.ok) {
      const errorBody = await response.text();
      console.error(`Gemini API error: ${response.status} - ${errorBody}`);
      return new Response(JSON.stringify({
        status: 'error',
        message: `Error from AI service: ${response.statusText}`,
        error: errorBody
      }), {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json',
        },
        status: response.status,
      });
    }

    const data = await response.json();

    // 6. Process the Gemini response - UPDATED to handle both array and object formats
    try {
        const rawResponse = data?.candidates?.[0]?.content?.parts?.[0]?.text
            ? JSON.parse(data.candidates[0].content.parts[0].text)
            : data;

        console.log('Raw AI response data:', JSON.stringify(rawResponse));

        // Handle both array format and object with contacts property
        if (Array.isArray(rawResponse)) {
          suggestedContacts = rawResponse;
        } else if (rawResponse && rawResponse.contacts && Array.isArray(rawResponse.contacts)) {
          suggestedContacts = rawResponse.contacts;
        } else {
          throw new Error("AI response is not a valid array of contact objects or object with contacts property.");
        }

        // Basic validation: Check if contacts have required fields
        if (suggestedContacts.some(c => typeof c !== 'object' || !c.name)) {
             throw new Error("AI response contains invalid contact objects.");
        }

        // Ensure exactly 1 contact
        suggestedContacts = suggestedContacts.slice(0, 1);
        
        // Additional validation: Check for duplicates against existing contacts
        const filteredContacts = suggestedContacts.filter(contact => {
          const contactNameLower = contact.name.toLowerCase().trim();
          const isDuplicate = existingContactNames.includes(contactNameLower);
          if (isDuplicate) {
            console.log(`Filtered out duplicate contact: ${contact.name}`);
          }
          return !isDuplicate;
        });
        
        if (filteredContacts.length !== suggestedContacts.length) {
          console.log(`Filtered out ${suggestedContacts.length - filteredContacts.length} duplicate contacts`);
        }
        
        suggestedContacts = filteredContacts;

    } catch (parseError) {
        console.error('Error parsing AI response:', parseError);
        console.error('Raw AI response data:', JSON.stringify(data));
        return new Response(JSON.stringify({
          status: 'error',
          message: 'Failed to process AI response structure for contacts.',
          error: parseError.message
        }), {
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json',
          },
          status: 500,
        });
    }

    // 7. Return a success response
    return new Response(JSON.stringify({
      status: 'success',
      message: 'Suggested contacts generated successfully.',
      contacts: suggestedContacts
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 200,
    });

  } catch (error) {
    console.error('Unexpected error during contact generation:', error);
    return new Response(JSON.stringify({
      status: 'error',
      message: 'An unexpected error occurred during contact generation.',
      error: error.message
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }
});
