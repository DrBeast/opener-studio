
import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.42.2';

// Define CORS headers using a constant
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'Authorization, Content-Type, x-client-info, apikey',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

// Define the Gemini API endpoint
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent';

// Define the expected structure for each suggested contact object generated by the AI
interface SuggestedContactOutput {
  name: string;
  role?: string;
  location?: string;
  linkedin_url?: string;
  email?: string;
  bio_summary?: string;
  how_i_can_help?: string;
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, {
      headers: corsHeaders
    });
  }

  // Create a Supabase client with the logged-in user's Auth token
  const authHeader = req.headers.get('Authorization');
  const supabaseClient = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_ANON_KEY') ?? '', // Use ANON key for client-side calls
    {
      global: {
        headers: { Authorization: authHeader ?? '' },
      },
    }
  );

  // Get the authenticated user's ID from the Supabase Auth context
  const { data: { user }, error: userError } = await supabaseClient.auth.getUser();

  if (userError || !user) {
    console.error('Authentication failed:', userError?.message);
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Authentication failed.',
      error: userError?.message
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 401,
    });
  }

  const userId = user.id;

  // Get the company_id from the request body
  const { company_id } = await req.json();

  if (!company_id) {
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Missing company_id in request body.',
      error: 'company_id is required.'
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      },
      status: 400,
    });
  }

  // Get the Gemini API Key securely from Supabase Secrets
  const geminiApiKey = Deno.env.get('GEMINI_API_KEY');

  if (!geminiApiKey) {
    console.error('Gemini API key not set in Supabase secrets.');
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Server configuration error.',
      error: 'Gemini API key not configured.'
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  // 1. Fetch existing contacts for this SPECIFIC COMPANY to prevent duplicates (FIXED)
  const { data: existingContacts, error: existingContactsError } = await supabaseClient
    .from('contacts')
    .select('first_name, last_name, role')
    .eq('user_id', userId)
    .eq('company_id', company_id); // CRITICAL FIX: Only check contacts for this specific company
    
  if (existingContactsError) {
    console.error('Error fetching existing contacts:', existingContactsError.message);
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to check for existing contacts.',
      error: existingContactsError.message
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      },
      status: 500
    });
  }

  // Create a list of existing contact names for this company only
  const existingContactNames = existingContacts?.map(contact => 
    `${contact.first_name} ${contact.last_name}`.toLowerCase().trim()
  ) || [];

  console.log(`Existing contacts for company ${company_id}:`, existingContactNames);

  // 2. Fetch the user's overall processed background summary from the user_summaries table
  const { data: userSummaryData, error: fetchSummaryError } = await supabaseClient
    .from('user_summaries')
    .select('*')
    .eq('user_id', userId)
    .single();

  if (fetchSummaryError || !userSummaryData) {
    console.error('Error fetching user summary:', fetchSummaryError?.message || 'Summary not found in user_summaries.');
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to fetch user background summary.',
      error: fetchSummaryError?.message || 'User summary data missing.'
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  const userSummary = userSummaryData;

  // 3. Fetch the user's job target criteria from the target_criteria table
  const { data: targetCriteria, error: fetchCriteriaError } = await supabaseClient
    .from('target_criteria')
    .select('*')
    .eq('user_id', userId)
    .single();

  if (fetchCriteriaError || !targetCriteria) {
    console.error('Error fetching target criteria:', fetchCriteriaError?.message || 'Criteria not found.');
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to fetch user target criteria.',
      error: fetchCriteriaError?.message || 'User target criteria missing.'
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  // 4. Fetch the details of the selected company from companies
  const { data: companyData, error: fetchCompanyError } = await supabaseClient
    .from('companies')
    .select('*')
    .eq('company_id', company_id)
    .eq('user_id', userId)
    .single();

  if (fetchCompanyError || !companyData) {
    console.error(`Error fetching company data for ID ${company_id}:`, fetchCompanyError?.message || 'Company not found.');
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to fetch company details.',
      error: fetchCompanyError?.message || `Company with ID ${company_id} not found for this user.`
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  // Helper function to get random variation in prompts
  const getPromptVariation = (attempt: number) => {
    const variations = [
      "Focus on identifying senior leadership or key decision-makers",
      "Prioritize contacts who would be most valuable for career advancement discussions",
      "Look for individuals in strategic roles who can provide industry insights",
      "Identify influential team leads or department heads who hire for your target function"
    ];
    return variations[attempt % variations.length];
  };

  // Helper function to generate contact with retry logic
  const generateContactWithRetry = async (attempt: number = 0): Promise<SuggestedContactOutput[]> => {
    const maxAttempts = 3;
    
    if (attempt >= maxAttempts) {
      throw new Error('Maximum retry attempts reached. Unable to generate unique contact.');
    }

    const promptVariation = getPromptVariation(attempt);
    const randomSeed = Math.random().toString(36).substring(7);

    // 5. Construct the enhanced prompt for the Gemini API
    const prompt = `
    You are an AI assistant helping a professional identify key contacts within a company for job search networking.
    Below is the user's professional background summary, their job target criteria, and details about the target company.

    IMPORTANT GUIDANCE: ${promptVariation}

    User Background Summary (Synthesized):
    Overall Blurb: ${userSummary.overall_blurb ?? 'N/A'}
    Experience Highlights: ${userSummary.combined_experience_highlights ? JSON.stringify(userSummary.combined_experience_highlights) : 'N/A'}
    Education Highlights: ${userSummary.combined_education_highlights ? JSON.stringify(userSummary.combined_education_highlights) : 'N/A'}
    Key Skills: ${userSummary.key_skills ? JSON.stringify(userSummary.key_skills) : 'N/A'}
    Domain Expertise: ${userSummary.domain_expertise ? JSON.stringify(userSummary.domain_expertise) : 'N/A'}
    Technical Expertise: ${userSummary.technical_expertise ? JSON.stringify(userSummary.technical_expertise) : 'N/A'}
    Value Proposition Summary: ${userSummary.value_proposition_summary ?? 'N/A'}

    User Job Target Criteria:
    Target Functions: ${targetCriteria.target_functions ? JSON.stringify(targetCriteria.target_functions) : 'Any'}
    Target Locations: ${targetCriteria.target_locations ? JSON.stringify(targetCriteria.target_locations) : 'Any'}
    Target WFH Preference: ${targetCriteria.target_wfh_preference ? JSON.stringify(targetCriteria.target_wfh_preference) : 'Any'}
    Free-form Role And Company Description: ${targetCriteria.free_form_role_description ?? 'None provided'}
    Target Industries: ${targetCriteria.target_industries ? JSON.stringify(targetCriteria.target_industries) : 'Any'}
    Target Sizes: ${targetCriteria.target_sizes ? JSON.stringify(targetCriteria.target_sizes) : 'Any'}
    Target Public/Private: ${targetCriteria.target_public_private ? JSON.stringify(targetCriteria.target_public_private) : 'Any'}
    Similar Companies (Inspiration): ${targetCriteria.similar_companies ? JSON.stringify(targetCriteria.similar_companies) : 'None provided'}
    Visa Sponsorship Required: ${targetCriteria.visa_sponsorship_required ? 'Yes' : 'No'}

    Target Company Details:
    Company Name: ${companyData.name}
    Company Description: ${companyData.ai_description ?? 'N/A'}
    Industry: ${companyData.industry ?? 'N/A'}
    Key Locations: ${companyData.hq_location ?? 'N/A'}
    Estimated Headcount: ${companyData.estimated_headcount ?? 'N/A'}
    Estimated Revenue: ${companyData.estimated_revenue ?? 'N/A'}
    WFH Policy: ${companyData.wfh_policy ?? 'N/A'}
    Public/Private: ${companyData.public_private ?? 'N/A'}

    IMPORTANT: The following contacts already exist for this company, so DO NOT suggest anyone with these names or very similar variations:
    ${JSON.stringify(existingContactNames)}

    PRIORITY GUIDANCE FOR CONTACT SELECTION:
    Based on the user's target functions and background, prioritize contacts in this order:
    1. **VP of Product, Chief Product Officer (CPO), or Head of Product** - These are often the most valuable connections for product-focused roles
    2. **VP of Engineering, CTO, or Engineering Directors** - Critical for technical roles and engineering positions  
    3. **Functional VPs relevant to user's target** (VP of Data, VP of AI/ML, VP of Strategy, etc.)
    4. **Senior Directors or Principal-level individual contributors** in the user's target domain
    5. **Hiring Managers or Team Leads** for specific functions the user is targeting
    6. **Recruiters or Talent Acquisition leaders** who focus on the user's target functions
    7. **CEO or other C-level executives** only if they're particularly relevant to the user's domain

    Your task is to identify 1 key individual within ${companyData.name} who would be most relevant for the user to connect with for job search networking, based on the user's background and target criteria. Focus on publicly available information and ensure the suggested contact is NOT a duplicate of existing contacts for this company.

    Random seed for variation: ${randomSeed}

    When identifying the contact, consider the user's current role and target functions, aiming for individuals in roles at or above the user's current level, understanding that seniority can vary significantly based on company size. Do not prioritize contacts based on their location.

    Provide the following information in a JSON array with exactly 1 contact object:

    For the contact object in the array:
    - "name": Full Name of the contact (ensure this is NOT similar to any existing contact names listed above for this company).
    - "role": The contact's job title/role.
    - "location": The contact's location (if available from public data).
    - "linkedin_url": Public LinkedIn URL if found (often hard to find reliably from public data).
    - "email": Public email address if found (very unlikely from public data). Do NOT guess or generate email addresses.
    - "bio_summary": A brief, 1-2 sentence summary of the contact's background or relevance based on publicly available information.
    - "how_i_can_help": A brief, 1-2 sentence explanation of *how the user* (referring to the user's background and skills) can potentially be of help or provide value to *this specific contact* or their team/company, based on the context.

    Ensure the output is a valid JSON array with exactly 1 contact object.

    Generate the JSON array:
    `;

    // Make the call to the Gemini API
    const response = await fetch(GEMINI_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': geminiApiKey,
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: prompt }]
        }],
        generationConfig: {
           temperature: 0.7 + (attempt * 0.1), // Increase randomness with each attempt
           responseMimeType: "application/json"
        },
      }),
    });

    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`Gemini API error: ${response.status} - ${errorBody}`);
    }

    const data = await response.json();

    // Process the Gemini response
    let suggestedContacts: SuggestedContactOutput[];
    try {
        const rawResponse = data?.candidates?.[0]?.content?.parts?.[0]?.text
            ? JSON.parse(data.candidates[0].content.parts[0].text)
            : data;

        console.log(`Raw AI response data (attempt ${attempt + 1}):`, JSON.stringify(rawResponse));

        // Handle both array format and object with contacts property
        if (Array.isArray(rawResponse)) {
          suggestedContacts = rawResponse;
        } else if (rawResponse && rawResponse.contacts && Array.isArray(rawResponse.contacts)) {
          suggestedContacts = rawResponse.contacts;
        } else {
          throw new Error("AI response is not a valid array of contact objects or object with contacts property.");
        }

        // Basic validation: Check if contacts have required fields
        if (suggestedContacts.some(c => typeof c !== 'object' || !c.name)) {
             throw new Error("AI response contains invalid contact objects.");
        }

        // Ensure exactly 1 contact
        suggestedContacts = suggestedContacts.slice(0, 1);
        
        // Check for duplicates against existing contacts for this company only
        const filteredContacts = suggestedContacts.filter(contact => {
          const contactNameLower = contact.name.toLowerCase().trim();
          const isDuplicate = existingContactNames.includes(contactNameLower);
          if (isDuplicate) {
            console.log(`Filtered out duplicate contact: ${contact.name} (attempt ${attempt + 1})`);
          }
          return !isDuplicate;
        });
        
        // If we filtered out duplicates and have no contacts left, retry with different prompt
        if (filteredContacts.length === 0 && suggestedContacts.length > 0) {
          console.log(`All contacts were duplicates on attempt ${attempt + 1}, retrying...`);
          return await generateContactWithRetry(attempt + 1);
        }
        
        return filteredContacts;

    } catch (parseError) {
        console.error(`Error parsing AI response on attempt ${attempt + 1}:`, parseError);
        if (attempt < maxAttempts - 1) {
          console.log('Retrying with different parameters...');
          return await generateContactWithRetry(attempt + 1);
        }
        throw new Error(`Failed to process AI response structure for contacts: ${parseError.message}`);
    }
  };

  // 6. Generate contact with retry logic
  try {
    const suggestedContacts = await generateContactWithRetry();

    // 7. Return success response
    return new Response(JSON.stringify({
      status: 'success',
      message: 'Suggested contacts generated successfully.',
      contacts: suggestedContacts
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 200,
    });

  } catch (error) {
    console.error('Error during contact generation:', error);
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to generate unique contact after multiple attempts.',
      error: error.message
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }
});
