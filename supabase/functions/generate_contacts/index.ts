
import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.42.2'; // Use the Supabase JS client

// Define CORS headers using a constant
const corsHeaders = {
  'Access-Control-Allow-Origin': '*', // Replace with your frontend origin in production
  'Access-Control-Allow-Headers': 'Authorization, Content-Type, x-client-info, apikey', // Include common headers
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

// Define the Gemini API endpoint
// Using gemini-1.5-pro for its reasoning ability to identify relevant people.
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent';

// Define the expected structure for each suggested contact object generated by the AI
// Updated: Removed seniority, added how_i_can_help
interface SuggestedContactOutput {
  name: string;
  role?: string; // Role/Title
  location?: string; // Location (still included as it might be in public data)
  linkedin_url?: string; // Public LinkedIn URL if found
  email?: string; // Public email if found (very unlikely from public data)
  bio_summary?: string; // AI-generated summary from public info
  how_i_can_help?: string; // New: 1-2 sentences on how the user can help this contact
}

serve(async (req) => {
  // --- CORS Handling ---
  // This allows your frontend (on a different domain/port) to call this function
  if (req.method === 'OPTIONS') {
    return new Response(null, {
      headers: corsHeaders
    });
  }
  // --- End CORS Handling ---

  // Create a Supabase client with the logged-in user's Auth token
  // This is the correct way to run the function *as the authenticated user* subject to RLS
  const authHeader = req.headers.get('Authorization');
  const supabaseClient = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_ANON_KEY') ?? '', // Use ANON key for client-side calls
    {
      global: {
        headers: { Authorization: authHeader ?? '' },
      },
    }
  );

  // Get the authenticated user's ID from the Supabase Auth context
  // This check remains important for security and RLS
  const { data: { user }, error: userError } = await supabaseClient.auth.getUser();

  if (userError || !user) {
    console.error('Authentication failed:', userError?.message);
    // Adjusted error response format with CORS headers
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Authentication failed.',
      error: userError?.message
    }), {
      headers: {
        ...corsHeaders, // Include CORS headers in error response
        'Content-Type': 'application/json',
      },
      status: 401, // Unauthorized
    });
  }

  const userId = user.id;

  // Get the company_id from the request body
  const { company_id } = await req.json();

  if (!company_id) {
    return new Response(JSON.stringify({
      status: 'error', // Adjusted response format
      message: 'Missing company_id in request body.',
      error: 'company_id is required.'
    }), {
      headers: {
        ...corsHeaders, // Include CORS headers
        'Content-Type': 'application/json'
      },
      status: 400, // Bad Request
    });
  }

  // Get the Gemini API Key securely from Supabase Secrets
  const geminiApiKey = Deno.env.get('GEMINI_API_KEY');

  if (!geminiApiKey) {
    console.error('Gemini API key not set in Supabase secrets.');
    // Adjusted error response format with CORS headers
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Server configuration error.',
      error: 'Gemini API key not configured.'
    }), {
      headers: {
        ...corsHeaders, // Include CORS headers
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  // 1. Fetch the user's overall processed background summary from the user_summaries table
  const { data: userSummaryData, error: fetchSummaryError } = await supabaseClient
    .from('user_summaries')
    .select('*') // Fetch all columns from the user_summaries row
    .eq('user_id', userId)
    .single(); // Expecting one summary row per user

  if (fetchSummaryError || !userSummaryData) {
    console.error('Error fetching user summary:', fetchSummaryError?.message || 'Summary not found in user_summaries.');
    // Adjusted error response format with CORS headers
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to fetch user background summary.',
      error: fetchSummaryError?.message || 'User summary data missing.'
    }), {
      headers: {
        ...corsHeaders, // Include CORS headers
        'Content-Type': 'application/json',
      },
      status: 500, // Or 400 if summary is a prerequisite
    });
  }

  const userSummary = userSummaryData;

  // 2. Fetch the user's job target criteria from the target_criteria table
  const { data: targetCriteria, error: fetchCriteriaError } = await supabaseClient
    .from('target_criteria')
    .select('*') // Fetch all columns
    .eq('user_id', userId)
    .single();

  if (fetchCriteriaError || !targetCriteria) {
    console.error('Error fetching target criteria:', fetchCriteriaError?.message || 'Criteria not found.');
    // Adjusted error response format with CORS headers
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to fetch user target criteria.',
      error: fetchCriteriaError?.message || 'User target criteria missing.'
    }), {
      headers: {
        ...corsHeaders, // Include CORS headers
        'Content-Type': 'application/json',
      },
      status: 500, // Or 400 if criteria is a prerequisite
    });
  }

  // 3. Fetch the details of the selected company from companies
  // RLS should ensure the user can only fetch their own companies
  const { data: companyData, error: fetchCompanyError } = await supabaseClient
    .from('companies')
    .select('*') // Fetch all columns
    .eq('company_id', company_id)
    .eq('user_id', userId) // Double check user_id for security
    .single();

  if (fetchCompanyError || !companyData) {
    console.error(`Error fetching company data for ID ${company_id}:`, fetchCompanyError?.message || 'Company not found.');
    // Adjusted error response format with CORS headers
    return new Response(JSON.stringify({
      status: 'error',
      message: 'Failed to fetch company details.',
      error: fetchCompanyError?.message || `Company with ID ${company_id} not found for this user.`
    }), {
      headers: {
        ...corsHeaders, // Include CORS headers
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }

  // 4. Construct the prompt for the Gemini API
  // Instruct Gemini to act as a networking assistant and identify contacts
  // Updated prompt based on new requirements
  const prompt = `
  You are an AI assistant helping a professional identify key contacts within a company for job search networking.
  Below is the user's professional background summary, their job target criteria, and details about the target company.

  User Background Summary (Synthesized):
  Overall Blurb: ${userSummary.overall_blurb ?? 'N/A'}
  Experience Highlights: ${userSummary.combined_experience_highlights ? JSON.stringify(userSummary.combined_experience_highlights) : 'N/A'}
  Education Highlights: ${userSummary.combined_education_highlights ? JSON.stringify(userSummary.combined_education_highlights) : 'N/A'}
  Key Skills: ${userSummary.key_skills ? JSON.stringify(userSummary.key_skills) : 'N/A'}
  Domain Expertise: ${userSummary.domain_expertise ? JSON.stringify(userSummary.domain_expertise) : 'N/A'}
  Technical Expertise: ${userSummary.technical_expertise ? JSON.stringify(userSummary.technical_expertise) : 'N/A'}
  Value Proposition Summary: ${userSummary.value_proposition_summary ?? 'N/A'}
  User's Current Role: ${userSummary.overall_blurb ?? 'N/A'} // Using overall_blurb as a proxy for current role/level
  // Include other relevant fields from user_summaries as needed

  User Job Target Criteria:
  Target Functions: ${targetCriteria.target_functions ? JSON.stringify(targetCriteria.target_functions) : 'Any'}
  Target Locations: ${targetCriteria.target_locations ? JSON.stringify(targetCriteria.target_locations) : 'Any'}
  Target WFH Preference: ${targetCriteria.target_wfh_preference ? JSON.stringify(targetCriteria.target_wfh_preference) : 'Any'}
  Free-form Role And Company Description: ${targetCriteria.free_form_role_description ?? 'None provided'}
  Target Industries: ${targetCriteria.target_industries ? JSON.stringify(targetCriteria.target_industries) : 'Any'}
  Target Sizes: ${targetCriteria.target_sizes ? JSON.stringify(targetCriteria.target_sizes) : 'Any'}
  Target Public/Private: ${targetCriteria.target_public_private ? JSON.stringify(targetCriteria.target_public_private) : 'Any'}
  Similar Companies (Inspiration): ${targetCriteria.similar_companies ? JSON.stringify(targetCriteria.similar_companies) : 'None provided'}
  Visa Sponsorship Required: ${targetCriteria.visa_sponsorship_required ? 'Yes' : 'No'}

  Target Company Details:
  Company Name: ${companyData.name}
  Company Description: ${companyData.ai_description ?? 'N/A'}
  Industry: ${companyData.industry ?? 'N/A'}
  Key Locations: ${companyData.hq_location ?? 'N/A'} // Using hq_location as key_locations from prompt
  Estimated Headcount: ${companyData.estimated_headcount ?? 'N/A'}
  Estimated Revenue: ${companyData.estimated_revenue ?? 'N/A'}
  WFH Policy: ${companyData.wfh_policy ?? 'N/A'}
  Public/Private: ${companyData.public_private ?? 'N/A'}
  // Include other relevant company fields

  Your task is to identify up to 3 key individuals within ${companyData.name} who would be most relevant for the user to connect with for job search networking, based on the user's background and target criteria. Focus on publicly available information.

  When identifying contacts, consider the user's current role and target functions, aiming for individuals in roles at or above the user's current level, understanding that seniority can vary significantly based on company size. Do not prioritize contacts based on their location.

  Prioritize individuals in roles like:
  - Leaders in the user's target function (1-2 levels above user's current/target seniority)
  - Relevant Executives (within 3 levels of user's target seniority)
  - Potential Peers currently holding similar roles/teams (at or above user's current level)
  - Recruiters or Talent Acquisition professionals focused on relevant functions/levels

  For each suggested contact, provide the following information in a structured JSON array. Limit the output to a maximum of 3 contacts.

  For each contact object in the array:
  - "name": Full Name of the contact.
  - "role": The contact's job title/role.
  // seniority: string; // Removed as per requirement
  - "location": The contact's location (if available from public data).
  - "linkedin_url": Public LinkedIn URL if found (often hard to find reliably from public data).
  - "email": Public email address if found (very unlikely from public data). Do NOT guess or generate email addresses.
  - "bio_summary": A brief, 1-2 sentence summary of the contact's background or relevance based on publicly available information.
  - "how_i_can_help": A brief, 1-2 sentence explanation of *how the user* (referring to the user's background and skills) can potentially be of help or provide value to *this specific contact* or their team/company, based on the context.

  Ensure the output is a valid JSON array of up to 3 contact objects.

  Generate the JSON array:
  `;

  // 5. Make the call to the Gemini API
  try {
    const response = await fetch(GEMINI_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': geminiApiKey, // Use the secured API key
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: prompt }]
        }],
        generationConfig: {
           temperature: 0.7, // Allow some creativity in identifying potential contacts
           responseMimeType: "application/json" // Request JSON output directly
        },
      }),
    });

    if (!response.ok) {
      const errorBody = await response.text();
      console.error(`Gemini API error: ${response.status} - ${errorBody}`);
      // Adjusted error response format with CORS headers
       return new Response(JSON.stringify({
         status: 'error',
         message: `Error from AI service: ${response.statusText}`,
         error: errorBody
       }), {
         headers: {
           ...corsHeaders, // Include CORS headers
           'Content-Type': 'application/json',
         },
         status: response.status,
       });
    }

    const data = await response.json();

    // 6. Process the Gemini response to extract the structured data (array of contacts)
    let suggestedContacts: SuggestedContactOutput[];
    try {
        suggestedContacts = data?.candidates?.[0]?.content?.parts?.[0]?.text
            ? JSON.parse(data.candidates[0].content.parts[0].text)
            : data; // Assume data is already parsed JSON if responseMimeType worked

        // Basic validation: Check if it's an array and contains objects with a 'name' field
        if (!Array.isArray(suggestedContacts) || suggestedContacts.some(c => typeof c !== 'object' || !c.name)) {
             throw new Error("AI response is not a valid array of contact objects.");
        }

        // Limit to max 3 contacts if AI returned more (should be handled by prompt, but as a safeguard)
        suggestedContacts = suggestedContacts.slice(0, 3);

    } catch (parseError) {
        console.error('Error parsing AI response:', parseError);
         console.error('Raw AI response data:', JSON.stringify(data)); // Log raw data for debugging
        // Adjusted error response format with CORS headers
        return new Response(JSON.stringify({
          status: 'error',
          message: 'Failed to process AI response structure for contacts.',
          error: parseError.message
        }), {
          headers: {
            ...corsHeaders, // Include CORS headers
            'Content-Type': 'application/json',
          },
          status: 500,
        });
    }

    // 7. Return a success response, including the suggested contacts data
    // The frontend will handle adding these to the DB if the user chooses to
    // Adjusted success response format
    return new Response(JSON.stringify({
      status: 'success',
      message: 'Suggested contacts generated successfully.',
      contacts: suggestedContacts // Return the list of suggested contacts
    }), {
      headers: {
        ...corsHeaders, // Include CORS headers
        'Content-Type': 'application/json',
      },
      status: 200,
    });

  } catch (error) {
    console.error('Unexpected error during contact generation:', error);
    // Adjusted error response format
    return new Response(JSON.stringify({
      status: 'error',
      message: 'An unexpected error occurred during contact generation.',
      error: error.message
    }), {
      headers: {
        ...corsHeaders, // Include CORS headers
        'Content-Type': 'application/json',
      },
      status: 500,
    });
  }
});
